(window.webpackJsonp=window.webpackJsonp||[]).push([[199],{664:function(s,t,a){"use strict";a.r(t);var i=a(11),e=Object(i.a)({},(function(){var s=this,t=s.$createElement,a=s._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[a("h1",{attrs:{id:"redis进阶---数据结构：redis对象与编码底层结构对应关系详解"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#redis进阶---数据结构：redis对象与编码底层结构对应关系详解"}},[s._v("¶")]),s._v(" Redis进阶 - 数据结构：redis对象与编码(底层结构)对应关系详解")]),s._v(" "),a("blockquote",[a("p",[s._v("在学习完"),a("RouterLink",{attrs:{to:"/md/db/nosql-redis/db-redis-x-redis-ds.html"}},[s._v("底层数据结构")]),s._v("之后，我们终于可以结合前文内容阐述redis对象及编码之间的关系了。@pdai")],1)]),s._v(" "),a("ul",[a("li",[a("a",{attrs:{href:"#redis%E8%BF%9B%E9%98%B6---%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84redis%E5%AF%B9%E8%B1%A1%E4%B8%8E%E7%BC%96%E7%A0%81%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84%E5%AF%B9%E5%BA%94%E5%85%B3%E7%B3%BB%E8%AF%A6%E8%A7%A3"}},[s._v("Redis进阶 - 数据结构：redis对象与编码(底层结构)对应关系详解")]),s._v(" "),a("ul",[a("li",[a("a",{attrs:{href:"#redis%E5%AF%B9%E8%B1%A1%E4%B8%8E%E7%BC%96%E7%A0%81%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84%E5%AF%B9%E5%BA%94%E5%85%B3%E7%B3%BB%E5%BC%95%E5%85%A5"}},[s._v("redis对象与编码(底层结构)对应关系引入")])]),s._v(" "),a("li",[a("a",{attrs:{href:"#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AF%B9%E8%B1%A1"}},[s._v("字符串对象")])]),s._v(" "),a("li",[a("a",{attrs:{href:"#%E5%88%97%E8%A1%A8%E5%AF%B9%E8%B1%A1"}},[s._v("列表对象")])]),s._v(" "),a("li",[a("a",{attrs:{href:"#%E5%93%88%E5%B8%8C%E5%AF%B9%E8%B1%A1"}},[s._v("哈希对象")])]),s._v(" "),a("li",[a("a",{attrs:{href:"#%E9%9B%86%E5%90%88%E5%AF%B9%E8%B1%A1"}},[s._v("集合对象")])]),s._v(" "),a("li",[a("a",{attrs:{href:"#%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88%E5%AF%B9%E8%B1%A1"}},[s._v("有序集合对象")])]),s._v(" "),a("li",[a("a",{attrs:{href:"#%E5%8F%82%E8%80%83%E6%96%87%E7%AB%A0"}},[s._v("参考文章")])])])])]),s._v(" "),a("h2",{attrs:{id:"redis对象与编码底层结构对应关系引入"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#redis对象与编码底层结构对应关系引入"}},[s._v("¶")]),s._v(" redis对象与编码(底层结构)对应关系引入")]),s._v(" "),a("p",[s._v("在对"),a("RouterLink",{attrs:{to:"/md/db/nosql-redis/db-redis-x-redis-object.html"}},[s._v("对象机制详解")]),s._v(" 和 "),a("RouterLink",{attrs:{to:"/md/db/nosql-redis/db-redis-x-redis-ds.html"}},[s._v("底层数据结构")]),s._v(" 有了初步认识之后，我们便可以继续理解它们是怎么对应的：")],1),s._v(" "),a("p",[a("img",{staticClass:"lazy",attrs:{alt:"","data-src":"https://pdai-1257820000.cos.ap-beijing.myqcloud.com/pdai.tech/public/_images/db/redis/db-redis-object-2-4.png",loading:"lazy"}})]),s._v(" "),a("h2",{attrs:{id:"字符串对象"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#字符串对象"}},[s._v("¶")]),s._v(" 字符串对象")]),s._v(" "),a("blockquote",[a("p",[s._v("字符串是Redis最基本的数据类型，不仅所有key都是字符串类型，其它几种数据类型构成的元素也是字符串。注意字符串的长度不能超过512M。")])]),s._v(" "),a("ul",[a("li",[a("strong",[s._v("编码")])])]),s._v(" "),a("p",[s._v("字符串对象的编码可以是int，raw或者embstr。")]),s._v(" "),a("ul",[a("li",[a("code",[s._v("int 编码")]),s._v("：保存的是可以用 long 类型表示的整数值。")]),s._v(" "),a("li",[a("code",[s._v("embstr 编码")]),s._v("：保存长度小于44字节的字符串（redis3.2版本之前是39字节，之后是44字节）。")]),s._v(" "),a("li",[a("code",[s._v("raw 编码")]),s._v("：保存长度大于44字节的字符串（redis3.2版本之前是39字节，之后是44字节）。")])]),s._v(" "),a("p",[a("img",{staticClass:"lazy",attrs:{alt:"","data-src":"https://pdai-1257820000.cos.ap-beijing.myqcloud.com/pdai.tech/public/_images/db/redis/db-redis-x-object-4.png",loading:"lazy"}})]),s._v(" "),a("p",[s._v("由上可以看出，int 编码是用来保存整数值，而embstr是用来保存短字符串，raw编码是用来保存长字符串。")]),s._v(" "),a("ul",[a("li",[a("strong",[s._v("内存布局")])])]),s._v(" "),a("p",[s._v("字符串对象支持三种编码方式: RAW, INT, EMBSTR, 三种方式的内存布局分别如下:")]),s._v(" "),a("p",[a("img",{staticClass:"lazy",attrs:{alt:"","data-src":"https://pdai-1257820000.cos.ap-beijing.myqcloud.com/pdai.tech/public/_images/db/redis/db-redis-ds-x-21.png",loading:"lazy"}})]),s._v(" "),a("ul",[a("li",[a("strong",[s._v("raw 和 embstr 的区别")])])]),s._v(" "),a("p",[s._v("其实 embstr 编码是专门用来保存短字符串的一种优化编码，raw 和 embstr 的区别：")]),s._v(" "),a("p",[s._v("embstr与raw都使用redisObject和sds保存数据，区别在于，embstr的使用只分配一次内存空间（因此redisObject和sds是连续的），而raw需要分配两次内存空间（分别为redisObject和sds分配空间）。因此与raw相比，embstr的好处在于创建时少分配一次空间，删除时少释放一次空间，以及对象的所有数据连在一起，寻找方便。而embstr的坏处也很明显，如果字符串的长度增加需要重新分配内存时，整个redisObject和sds都需要重新分配空间，因此redis中的embstr实现为只读。")]),s._v(" "),a("p",[s._v("ps："),a("strong",[s._v("Redis中对于浮点数类型也是作为字符串保存的，在需要的时候再将其转换成浮点数类型")]),s._v("。")]),s._v(" "),a("ul",[a("li",[a("strong",[s._v("编码的转换")])])]),s._v(" "),a("p",[s._v("当 int 编码保存的值不再是整数，或大小超过了long的范围时，自动转化为raw。")]),s._v(" "),a("p",[s._v("对于 embstr 编码，由于 Redis 没有对其编写任何的修改程序（embstr 是只读的），在对embstr对象进行修改时，都会先转化为raw再进行修改，因此，只要是修改embstr对象，修改后的对象一定是raw的，无论是否达到了44个字节。")]),s._v(" "),a("h2",{attrs:{id:"列表对象"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#列表对象"}},[s._v("¶")]),s._v(" 列表对象")]),s._v(" "),a("blockquote",[a("p",[s._v("list 列表，它是简单的字符串列表，按照插入顺序排序，你可以添加一个元素到列表的头部（左边）或者尾部（右边），它的底层实际上是个链表结构。")])]),s._v(" "),a("ul",[a("li",[a("strong",[s._v("编码")])])]),s._v(" "),a("p",[s._v("列表对象的编码是quicklist。 (之前版本中有linked和ziplist这两种编码。进一步的, 目前Redis定义的10个对象编码方式宏名中, 有两个被完全闲置了, 分别是: "),a("code",[s._v("OBJ_ENCODING_ZIPMAP")]),s._v("与"),a("code",[s._v("OBJ_ENCODING_LINKEDLIST")]),s._v("。 从Redis的演进历史上来看, 前者是后续可能会得到支持的编码值（代码还在）, 后者则应该是被彻底淘汰了)")]),s._v(" "),a("ul",[a("li",[a("strong",[s._v("内存布局")])])]),s._v(" "),a("p",[s._v("列表对象的内存布局如下图所示:")]),s._v(" "),a("p",[a("img",{staticClass:"lazy",attrs:{alt:"","data-src":"https://pdai-1257820000.cos.ap-beijing.myqcloud.com/pdai.tech/public/_images/db/redis/db-redis-ds-x-22.png",loading:"lazy"}})]),s._v(" "),a("h2",{attrs:{id:"哈希对象"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#哈希对象"}},[s._v("¶")]),s._v(" 哈希对象")]),s._v(" "),a("blockquote",[a("p",[s._v("哈希对象的键是一个字符串类型，值是一个键值对集合。")])]),s._v(" "),a("ul",[a("li",[a("strong",[s._v("编码")])])]),s._v(" "),a("p",[s._v("哈希对象的编码可以是 ziplist 或者 hashtable；对应的底层实现有两种, 一种是ziplist, 一种是dict。")]),s._v(" "),a("p",[s._v("两种编码"),a("strong",[s._v("内存布局")]),s._v("分别如下:")]),s._v(" "),a("p",[a("img",{staticClass:"lazy",attrs:{alt:"","data-src":"https://pdai-1257820000.cos.ap-beijing.myqcloud.com/pdai.tech/public/_images/db/redis/db-redis-ds-x-23.png",loading:"lazy"}})]),s._v(" "),a("p",[s._v("上图中不严谨的地方有:")]),s._v(" "),a("ol",[a("li",[s._v("ziplist中每个entry, 除了键与值本身的二进制数据, 还包括其它字段, 图中没有画出来")]),s._v(" "),a("li",[s._v("dict底层可能持有两个dictht实例")]),s._v(" "),a("li",[s._v("没有画出dict的哈希冲突")])]),s._v(" "),a("p",[s._v("需要注意的是: 当采用HT编码, 即使用dict作为哈希对象的底层数据结构时, 键与值均是以sds的形式存储的.")]),s._v(" "),a("ul",[a("li",[a("strong",[s._v("举例说明")])])]),s._v(" "),a("p",[s._v("当使用ziplist，也就是压缩列表作为底层实现时，新增的键值对是保存到压缩列表的表尾。比如执行以下命令：")]),s._v(" "),a("div",{staticClass:"language-bash line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-bash"}},[a("code",[s._v("hset profile name "),a("span",{pre:!0,attrs:{class:"token string"}},[s._v('"Tom"')]),s._v("\nhset profile age "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("25")]),s._v("\nhset profile career "),a("span",{pre:!0,attrs:{class:"token string"}},[s._v('"Programmer"')]),s._v("\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br")])]),a("p",[s._v("如果使用ziplist，profile 存储如下：")]),s._v(" "),a("p",[a("img",{staticClass:"lazy",attrs:{alt:"","data-src":"https://pdai-1257820000.cos.ap-beijing.myqcloud.com/pdai.tech/public/_images/db/redis/db-redis-x-object-9.png",loading:"lazy"}})]),s._v(" "),a("p",[s._v("当使用 hashtable 编码时，上面命令存储如下：")]),s._v(" "),a("p",[a("img",{staticClass:"lazy",attrs:{alt:"","data-src":"https://pdai-1257820000.cos.ap-beijing.myqcloud.com/pdai.tech/public/_images/db/redis/db-redis-x-object-10.png",loading:"lazy"}})]),s._v(" "),a("p",[s._v("hashtable 编码的哈希表对象底层使用字典数据结构，哈希对象中的每个键值对都使用一个字典键值对。")]),s._v(" "),a("p",[s._v("在前面介绍压缩列表时，我们介绍过压缩列表是Redis为了节省内存而开发的，是由一系列特殊编码的连续内存块组成的顺序型数据结构，相对于字典数据结构，压缩列表用于元素个数少、元素长度小的场景。其优势在于集中存储，节省空间。")]),s._v(" "),a("ul",[a("li",[a("strong",[s._v("编码转换")])])]),s._v(" "),a("p",[s._v("和上面列表对象使用 ziplist 编码一样，当同时满足下面两个条件时，使用ziplist（压缩列表）编码：")]),s._v(" "),a("p",[s._v("1、列表保存元素个数小于512个")]),s._v(" "),a("p",[s._v("2、每个元素长度小于64字节")]),s._v(" "),a("p",[s._v("不能满足这两个条件的时候使用 hashtable 编码。第一个条件可以通过配置文件中的 "),a("code",[s._v("set-max-intset-entries")]),s._v(" 进行修改。")]),s._v(" "),a("h2",{attrs:{id:"集合对象"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#集合对象"}},[s._v("¶")]),s._v(" 集合对象")]),s._v(" "),a("blockquote",[a("p",[s._v("集合对象 set 是 string 类型（整数也会转换成string类型进行存储）的无序集合。注意集合和列表的区别：集合中的元素是无序的，因此不能通过索引来操作元素；集合中的元素不能有重复。")])]),s._v(" "),a("ul",[a("li",[a("strong",[s._v("编码")])])]),s._v(" "),a("p",[s._v("集合对象的编码可以是 intset 或者 hashtable; 底层实现有两种, 分别是intset和dict。 显然当使用intset作为底层实现的数据结构时, 集合中存储的只能是数值数据, 且必须是整数; 而当使用dict作为集合对象的底层实现时, 是将数据全部存储于dict的键中, 值字段闲置不用.")]),s._v(" "),a("p",[s._v("集合对象的内存布局如下图所示:")]),s._v(" "),a("p",[a("img",{staticClass:"lazy",attrs:{alt:"","data-src":"https://pdai-1257820000.cos.ap-beijing.myqcloud.com/pdai.tech/public/_images/db/redis/db-redis-ds-x-24.png",loading:"lazy"}})]),s._v(" "),a("ul",[a("li",[a("strong",[s._v("举例说明")])])]),s._v(" "),a("div",{staticClass:"language-bash line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-bash"}},[a("code",[s._v("SADD numbers "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("1")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("3")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("5")]),s._v("\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br")])]),a("p",[a("img",{staticClass:"lazy",attrs:{alt:"","data-src":"https://pdai-1257820000.cos.ap-beijing.myqcloud.com/pdai.tech/public/_images/db/redis/db-redis-x-object-11.png",loading:"lazy"}})]),s._v(" "),a("div",{staticClass:"language-bash line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-bash"}},[a("code",[s._v("SADD Dfruits "),a("span",{pre:!0,attrs:{class:"token string"}},[s._v('"apple"')]),s._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[s._v('"banana"')]),s._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[s._v('"cherry"')]),s._v("\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br")])]),a("p",[a("img",{staticClass:"lazy",attrs:{alt:"","data-src":"https://pdai-1257820000.cos.ap-beijing.myqcloud.com/pdai.tech/public/_images/db/redis/db-redis-x-object-12.png",loading:"lazy"}})]),s._v(" "),a("ul",[a("li",[a("strong",[s._v("编码转换")])])]),s._v(" "),a("p",[s._v("当集合同时满足以下两个条件时，使用 intset 编码：")]),s._v(" "),a("p",[s._v("1、集合对象中所有元素都是整数")]),s._v(" "),a("p",[s._v("2、集合对象所有元素数量不超过512")]),s._v(" "),a("p",[s._v("不能满足这两个条件的就使用 hashtable 编码。第二个条件可以通过配置文件的 "),a("code",[s._v("set-max-intset-entries")]),s._v(" 进行配置。")]),s._v(" "),a("h2",{attrs:{id:"有序集合对象"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#有序集合对象"}},[s._v("¶")]),s._v(" 有序集合对象")]),s._v(" "),a("blockquote",[a("p",[s._v("和上面的集合对象相比，有序集合对象是有序的。与列表使用索引下标作为排序依据不同，有序集合为每个元素设置一个分数（score）作为排序依据。")])]),s._v(" "),a("ul",[a("li",[a("strong",[s._v("编码")])])]),s._v(" "),a("p",[s._v("有序集合的底层实现依然有两种, 一种是使用ziplist作为底层实现, 另外一种比较特殊, 底层使用了两种数据结构: dict与skiplist. 前者对应的编码值宏为ZIPLIST, 后者对应的编码值宏为SKIPLIST")]),s._v(" "),a("p",[s._v("使用ziplist来实现在序集合很容易理解, 只需要在ziplist这个数据结构的基础上做好排序与去重就可以了. 使用zskiplist来实现有序集合也很容易理解, Redis中实现的这个跳跃表似乎天然就是为了实现有序集合对象而实现的, 那么为什么还要辅助一个dict实例呢? 我们先看来有序集合对象在这两种编码方式下的内存布局, 然后再做解释:")]),s._v(" "),a("p",[s._v("首先是编码为ZIPLIST时, 有序集合的内存布局如下:")]),s._v(" "),a("p",[a("img",{staticClass:"lazy",attrs:{alt:"","data-src":"https://pdai-1257820000.cos.ap-beijing.myqcloud.com/pdai.tech/public/_images/db/redis/db-redis-ds-x-25.png",loading:"lazy"}})]),s._v(" "),a("p",[s._v("然后是编码为SKIPLIST时, 有序集合的内存布局如下:")]),s._v(" "),a("p",[a("img",{staticClass:"lazy",attrs:{alt:"","data-src":"https://pdai-1257820000.cos.ap-beijing.myqcloud.com/pdai.tech/public/_images/db/redis/db-redis-ds-x-26.png",loading:"lazy"}})]),s._v(" "),a("p",[s._v("说明：其实有序集合单独使用字典或跳跃表其中一种数据结构都可以实现，但是这里使用两种数据结构组合起来，原因是假如我们单独使用 字典，虽然能以 O(1) 的时间复杂度查找成员的分值，但是因为字典是以无序的方式来保存集合元素，所以每次进行范围操作的时候都要进行排序；假如我们单独使用跳跃表来实现，虽然能执行范围操作，但是查找操作有 O(1)的复杂度变为了O(logN)。因此Redis使用了两种数据结构来共同实现有序集合。")]),s._v(" "),a("ul",[a("li",[a("strong",[s._v("举例说明")])])]),s._v(" "),a("div",{staticClass:"language-bash line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-bash"}},[a("code",[s._v("ZADD price "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("8.5")]),s._v(" apple "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("5.0")]),s._v(" banana "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("6.0")]),s._v(" cherry\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br")])]),a("p",[a("img",{staticClass:"lazy",attrs:{alt:"","data-src":"https://pdai-1257820000.cos.ap-beijing.myqcloud.com/pdai.tech/public/_images/db/redis/db-redis-x-object-13.png",loading:"lazy"}})]),s._v(" "),a("p",[a("img",{staticClass:"lazy",attrs:{alt:"","data-src":"https://pdai-1257820000.cos.ap-beijing.myqcloud.com/pdai.tech/public/_images/db/redis/db-redis-x-object-14.png",loading:"lazy"}})]),s._v(" "),a("ul",[a("li",[a("strong",[s._v("编码转换")])])]),s._v(" "),a("p",[s._v("当有序集合对象同时满足以下两个条件时，对象使用 ziplist 编码：")]),s._v(" "),a("p",[s._v("1、保存的元素数量小于128；")]),s._v(" "),a("p",[s._v("2、保存的所有元素长度都小于64字节。")]),s._v(" "),a("p",[s._v("不能满足上面两个条件的使用 skiplist 编码。以上两个条件也可以通过Redis配置文件"),a("code",[s._v("zset-max-ziplist-entries")]),s._v(" 选项和 "),a("code",[s._v("zset-max-ziplist-value")]),s._v(" 进行修改。")]),s._v(" "),a("h2",{attrs:{id:"参考文章"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#参考文章"}},[s._v("¶")]),s._v(" 参考文章")]),s._v(" "),a("p",[s._v("https://www.cnblogs.com/ysocean/p/9080942.html")]),s._v(" "),a("p",[s._v("http://redisbook.com/preview/dict/datastruct.html")]),s._v(" "),a("p",[s._v("https://www.cnblogs.com/neooelric/p/9621736.html")])])}),[],!1,null,null,null);t.default=e.exports}}]);