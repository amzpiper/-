(window.webpackJsonp=window.webpackJsonp||[]).push([[73],{537:function(e,a,t){"use strict";t.r(a);var b=t(11),v=Object(b.a)({},(function(){var e=this,a=e.$createElement,t=e._self._c||a;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"大数据处理---双层桶划分"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#大数据处理---双层桶划分"}},[e._v("¶")]),e._v(" 大数据处理 - 双层桶划分")]),e._v(" "),t("blockquote",[t("p",[e._v("本文主要介绍大数据处理之分桶处理。@pdai")])]),e._v(" "),t("ul",[t("li",[t("a",{attrs:{href:"#%e5%a4%a7%e6%95%b0%e6%8d%ae%e5%a4%84%e7%90%86---%e5%8f%8c%e5%b1%82%e6%a1%b6%e5%88%92%e5%88%86"}},[e._v("大数据处理 - 双层桶划分")]),e._v(" "),t("ul",[t("li",[t("a",{attrs:{href:"#%e5%88%86%e6%a1%b6%e6%b3%95%e7%ae%80%e4%bb%8b"}},[e._v("分桶法简介")])]),e._v(" "),t("li",[t("a",{attrs:{href:"#%e7%9b%b8%e5%85%b3%e9%a2%98%e7%9b%ae"}},[e._v("相关题目")]),e._v(" "),t("ul",[t("li",[t("a",{attrs:{href:"#25%e4%ba%bf%e4%b8%aa%e6%95%b4%e6%95%b0%e4%b8%ad%e6%89%be%e5%87%ba%e4%b8%8d%e9%87%8d%e5%a4%8d%e7%9a%84%e6%95%b4%e6%95%b0%e7%9a%84%e4%b8%aa%e6%95%b0%e5%86%85%e5%ad%98%e7%a9%ba%e9%97%b4%e4%b8%8d%e8%b6%b3%e4%bb%a5%e5%ae%b9%e7%ba%b3%e8%bf%9925%e4%ba%bf%e4%b8%aa%e6%95%b4%e6%95%b0"}},[e._v("2.5亿个整数中找出不重复的整数的个数，内存空间不足以容纳这2.5亿个整数。")])]),e._v(" "),t("li",[t("a",{attrs:{href:"#5%e4%ba%bf%e4%b8%aaint%e6%89%be%e5%ae%83%e4%bb%ac%e7%9a%84%e4%b8%ad%e4%bd%8d%e6%95%b0"}},[e._v("5亿个int找它们的中位数。")])])])])])])]),e._v(" "),t("h2",{attrs:{id:"分桶法简介"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#分桶法简介"}},[e._v("¶")]),e._v(" 分桶法简介")]),e._v(" "),t("p",[e._v("其实本质上还是分而治之的思想，重在“分”的技巧上！")]),e._v(" "),t("ul",[t("li",[t("code",[e._v("适用范围")]),e._v(": 第k大，中位数，不重复或重复的数字")]),e._v(" "),t("li",[t("code",[e._v("基本原理及要点")]),e._v(": 因为元素范围很大，不能利用直接寻址表，所以通过多次划分，逐步确定范围，然后最后在一个可以接受的范围内进行。")])]),e._v(" "),t("h2",{attrs:{id:"相关题目"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#相关题目"}},[e._v("¶")]),e._v(" 相关题目")]),e._v(" "),t("h3",{attrs:{id:"25亿个整数中找出不重复的整数的个数内存空间不足以容纳这25亿个整数"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#25亿个整数中找出不重复的整数的个数内存空间不足以容纳这25亿个整数"}},[e._v("¶")]),e._v(" 2.5亿个整数中找出不重复的整数的个数，内存空间不足以容纳这2.5亿个整数。")]),e._v(" "),t("p",[e._v("有点像鸽巢原理，整数个数为2^32,也就是，我们可以将这2^32个数，划分为2^8个区域(比如用单个文件代表一个区域)，然后将数据分离到不同的区域，然后不同的区域在利用bitmap就可以直接解决了。也就是说只要有足够的磁盘空间，就可以很方便的解决。")]),e._v(" "),t("h3",{attrs:{id:"5亿个int找它们的中位数"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#5亿个int找它们的中位数"}},[e._v("¶")]),e._v(" 5亿个int找它们的中位数。")]),e._v(" "),t("ul",[t("li",[t("strong",[e._v("思路一")])])]),e._v(" "),t("p",[e._v("这个例子比上面那个更明显。首先我们将int划分为2^16个区域，然后读取数据统计落到各个区域里的数的个数，之后我们根据统计结果就可以判断中位数落到那个区域，同时知道这个区域中的第几大数刚好是中位数。然后第二次扫描我们只统计落在这个区域中的那些数就可以了。")]),e._v(" "),t("p",[e._v("实际上，如果不是int是int64，我们可以经过3次这样的划分即可降低到可以接受的程度。即可以先将int64分成2^24个区域，然后确定区域的第几大数，在将该区域分成2^20个子区域，然后确定是子区域的第几大数，然后子区域里的数的个数只有2^20，就可以直接利用direct addr table进行统计了。")]),e._v(" "),t("ul",[t("li",[t("strong",[e._v("思路二")])])]),e._v(" "),t("p",[e._v("同样需要做两遍统计，如果数据存在硬盘上，就需要读取2次。")]),e._v(" "),t("p",[e._v("方法同基数排序有些像，开一个大小为65536的Int数组，第一遍读取，统计Int32的高16位的情况，也就是0-65535，都算作0,65536 - 131071都算作1。就相当于用该数除以65536。Int32 除以 65536的结果不会超过65536种情况，因此开一个长度为65536的数组计数就可以。每读取一个数，数组中对应的计数+1，考虑有负数的情况，需要将结果加32768后，记录在相应的数组内。")]),e._v(" "),t("p",[e._v("第一遍统计之后，遍历数组，逐个累加统计，看中位数处于哪个区间，比如处于区间k，那么0- k-1的区间里数字的数量sum应该"),t("code",[e._v("<n/2")]),e._v("(2.5亿)。而k+1 - 65535的计数和也"),t("code",[e._v("<n/2")]),e._v("，第二遍统计同上面的方法类似，但这次只统计处于区间k的情况，也就是说(x / 65536) + 32768 = k。统计只统计低16位的情况。并且利用刚才统计的sum，比如sum = 2.49亿，那么现在就是要在低16位里面找100万个数(2.5亿-2.49亿)。这次计数之后，再统计一下，看中位数所处的区间，最后将高位和低位组合一下就是结果了。")])])}),[],!1,null,null,null);a.default=v.exports}}]);