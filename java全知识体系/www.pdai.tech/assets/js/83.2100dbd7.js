(window.webpackJsonp=window.webpackJsonp||[]).push([[83],{548:function(t,a,i){"use strict";i.r(a);var r=i(11),o=Object(r.a)({},(function(){var t=this,a=t.$createElement,i=t._self._c||a;return i("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[i("h1",{attrs:{id:"字符串匹配---overview"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#字符串匹配---overview"}},[t._v("¶")]),t._v(" 字符串匹配 - Overview")]),t._v(" "),i("blockquote",[i("p",[t._v("字符串匹配(String Matchiing)也称字符串搜索(String Searching)是字符串算法中重要的一种，是指从一个大字符串或文本中找到模式串出现的位置。")])]),t._v(" "),i("ul",[i("li",[i("a",{attrs:{href:"#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D---overview"}},[t._v("字符串匹配 - Overview")]),t._v(" "),i("ul",[i("li",[i("a",{attrs:{href:"#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E6%A6%82%E5%BF%B5"}},[t._v("字符串匹配概念")])]),t._v(" "),i("li",[i("a",{attrs:{href:"#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95"}},[t._v("字符串匹配算法")])])])])]),t._v(" "),i("h2",{attrs:{id:"字符串匹配概念"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#字符串匹配概念"}},[t._v("¶")]),t._v(" 字符串匹配概念")]),t._v(" "),i("blockquote",[i("p",[t._v("字符串匹配问题的形式定义：")])]),t._v(" "),i("ul",[i("li",[t._v("文本（Text）是一个长度为 n 的数组 T[1..n]；")]),t._v(" "),i("li",[t._v("模式（Pattern）是一个长度为 m 且 m≤n 的数组 P[1..m]；")]),t._v(" "),i("li",[t._v("T 和 P 中的元素都属于有限的字母表 Σ 表；")]),t._v(" "),i("li",[t._v("如果 0≤s≤n-m，并且 T[s+1..s+m] = P[1..m]，即对 1≤j≤m，有 T[s+j] = P[j]，则说模式 P 在文本 T 中出现且位移为 s，且称 s 是一个有效位移（Valid Shift）。")])]),t._v(" "),i("p",[i("img",{staticClass:"lazy",attrs:{alt:"","data-src":"https://pdai-1257820000.cos.ap-beijing.myqcloud.com/pdai.tech/public/_images/alg/alg-domain-char-match-11.png",loading:"lazy"}})]),t._v(" "),i("p",[t._v("比如上图中，目标是找出所有在文本 T = abcabaabcabac 中模式 P = abaa 的所有出现。该模式在此文本中仅出现一次，即在位移 s = 3 处，位移 s = 3 是有效位移。")]),t._v(" "),i("p",[t._v("字符串匹配算法通常分为两个步骤：预处理（Preprocessing）和匹配（Matching）。所以算法的总运行时间为预处理和匹配的时间的总和。")]),t._v(" "),i("p",[i("img",{staticClass:"lazy",attrs:{alt:"","data-src":"https://pdai-1257820000.cos.ap-beijing.myqcloud.com/pdai.tech/public/_images/alg/alg-domain-char-match-12.png",loading:"lazy"}})]),t._v(" "),i("p",[t._v("上图描述了常见字符串匹配算法的预处理和匹配时间。")]),t._v(" "),i("p",[i("img",{staticClass:"lazy",attrs:{alt:"","data-src":"https://pdai-1257820000.cos.ap-beijing.myqcloud.com/pdai.tech/public/_images/alg/alg-domain-char-1.gif",loading:"lazy"}})]),t._v(" "),i("h2",{attrs:{id:"字符串匹配算法"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#字符串匹配算法"}},[t._v("¶")]),t._v(" 字符串匹配算法")]),t._v(" "),i("blockquote",[i("p",[t._v("解决字符串匹配的算法包括："),i("code",[t._v("朴素算法（Naive Algorithm）")]),t._v(" 即暴力破解、"),i("code",[t._v("Rabin-Karp 算法")]),t._v("、"),i("code",[t._v("有限自动机算法（Finite Automation）")]),t._v("、 "),i("code",[t._v("Knuth-Morris-Pratt 算法（即 KMP Algorithm）")]),t._v("、"),i("code",[t._v("Boyer-Moore 算法")]),t._v("、"),i("code",[t._v("Simon 算法")]),t._v("、"),i("code",[t._v("Colussi 算法")]),t._v("、"),i("code",[t._v("Galil-Giancarlo 算法")]),t._v("、"),i("code",[t._v("Apostolico-Crochemore 算法")]),t._v("、"),i("code",[t._v("Horspool 算法")]),t._v("和 "),i("code",[t._v("Sunday 算法")]),t._v("等。")])]),t._v(" "),i("ul",[i("li",[i("RouterLink",{attrs:{to:"/md/algorithm/alg-domain-char-match-bf.html"}},[t._v("朴素的字符串匹配算法（Naive String Matching Algorithm)")]),t._v(" "),i("ul",[i("li",[t._v("朴素的字符串匹配算法又称为"),i("strong",[t._v("暴力匹配算法")]),t._v("（Brute Force Algorithm），最为简单的字符串匹配算法")])])],1),t._v(" "),i("li",[i("RouterLink",{attrs:{to:"/md/algorithm/alg-domain-char-match-kmp.html"}},[t._v("Knuth-Morris-Pratt 字符串匹配算法（即 KMP 算法）")]),t._v(" "),i("ul",[i("li",[t._v("Knuth-Morris-Pratt算法（简称KMP）是最常用的字符串匹配算法之一")])])],1),t._v(" "),i("li",[i("RouterLink",{attrs:{to:"/md/algorithm/alg-domain-char-match-bm.html"}},[t._v("Boyer-Moore 字符串匹配算法")]),t._v(" "),i("ul",[i("li",[t._v('各种文本编辑器的"查找"功能（Ctrl+F），大多采用Boyer-Moore算法，效率非常高')])])],1),t._v(" "),i("li",[i("RouterLink",{attrs:{to:"/md/algorithm/alg-domain-char-match-st.html"}},[t._v("字符串匹配 - 文本预处理：后缀树（Suffix Tree）")]),t._v(" "),i("ul",[i("li",[t._v("上述字符串匹配算法(朴素的字符串匹配算法, KMP 算法, Boyer-Moore算法)均是通过对"),i("strong",[t._v("模式（Pattern）字符串进行预处理")]),t._v("的方式来加快搜索速度。对 Pattern 进行预处理的最优复杂度为 O(m)，其中 m 为 Pattern 字符串的长度。那么，有没有对文本（Text）进行预处理的算法呢？本文即将介绍一种"),i("strong",[t._v("对 Text 进行预处理")]),t._v("的字符串匹配算法：后缀树（Suffix Tree）")])])],1)])])}),[],!1,null,null,null);a.default=o.exports}}]);